<!DOCTYPE html>



  



<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="线程创建的方法Runnable12345678910111213public class RunnableTest implements Runnable &amp;#123;    @Override    public void run() &amp;#123;//执行具体的逻辑        System.out.println(Thread.currentThread()+&quot;启动&quot;);    &amp;#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发">
<meta property="og:url" content="http://yoursite.com/2019/04/05/java并发/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="线程创建的方法Runnable12345678910111213public class RunnableTest implements Runnable &amp;#123;    @Override    public void run() &amp;#123;//执行具体的逻辑        System.out.println(Thread.currentThread()+&quot;启动&quot;);    &amp;#125;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-07T03:15:31.821Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发">
<meta name="twitter:description" content="线程创建的方法Runnable12345678910111213public class RunnableTest implements Runnable &amp;#123;    @Override    public void run() &amp;#123;//执行具体的逻辑        System.out.println(Thread.currentThread()+&quot;启动&quot;);    &amp;#125;">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/05/java并发/">





  <title>java并发 | 我的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">哪有什么胜利可言，挺着就代表着一切</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/05/java并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lichukuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/user.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java并发</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-05T21:26:16+08:00">
                2019-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="线程创建的方法"><a href="#线程创建的方法" class="headerlink" title="线程创建的方法"></a>线程创建的方法</h2><h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//执行具体的逻辑</span></span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">"启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Runnable runnable = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">   Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">   thread.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">"启动"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Thread thread = <span class="keyword">new</span> MyThread(<span class="string">"线程"</span>);</span><br><span class="line">  thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="Callable和Future"></a>Callable和Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"完成了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">   FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">   Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">   t.start();</span><br><span class="line">   System.out.println(task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Callable</code>和<code>Runnable</code>的主要区别是，<code>Callable</code>是有返回值的。</p>
<p><code>FutureTask</code>是包装类，可将<code>Callable</code>转换为<code>Future</code>和<code>Runable</code>，它同时实现<br>了二者的接口。<code>Future</code>接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//取消未开始执行的方法，如果方法已经执行，并且mayInterruptIfRunning=true，则中断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;<span class="comment">//判断是否被取消</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;<span class="comment">//判断call是否执行完了</span></span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;<span class="comment">//get()方法的调用会被堵塞，直到call方法中方法执行完成</span></span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="comment">//调用超时时，会抛出异常</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程有六种状态，分别如下：</p>
<ul>
<li>New (新创建)</li>
<li>Runnable (可运行)</li>
<li>Blocked (被阻塞)</li>
<li>Waiting (等待)</li>
<li>Timed waitting (计时等待)</li>
<li>Terminated (被终止)</li>
</ul>
<p>可以通过<code>getState()</code>获取线程所处的状态</p>
<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> <span class="comment">//请求线程中断，线程不一定会中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> <span class="comment">//检测当前线程是否中断，不会改变中断状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> <span class="comment">//检测当前线程是否中断，会重置中断状态为false</span></span></span><br></pre></td></tr></table></figure>
<p><code>isInterrupted()</code>和<code>interrupted()</code>的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true表示重置中断状态为false，false表示不改变中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意：当线程处于<code>New</code>或<code>Terminated</code>状态时，中断操作无效，即中断状态不会改变；<br>当线程处于<code>Runnable</code>或<code>Blocked</code>时，中断操作只会改变中断状态，并不会中断程序，<br>这时需要我们使用<code>if(Thread.currentThread().isInterrupted())</code>来判断是否处于中断状态，<br>自己处理，这样增加了灵活性；当线程处于<code>Waiting</code>或<code>Timed waitting</code>时，中断操作会<br>抛出异常，并且结束程序。</p>
<p>过时的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> 等待终止指定的线程</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> 等待指定的线程死亡或者经过指定的毫秒数</span></span><br></pre></td></tr></table></figure>
<p>等待所有的线程执行后执行<code>main</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Thread&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread(<span class="string">"线程"</span>+i);</span><br><span class="line">    thread.start();</span><br><span class="line">    list.add(thread);</span><br><span class="line">&#125;</span><br><span class="line">list.forEach(t -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t.join();<span class="comment">//注意，join方法只有在start方法之后调用才有效</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"主线程执行"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>每一个线程都有一个优先级，在默认的情况下，一个线程继承它父类线程的优先级。<br>可以使用<code>setPriority(int newPriority)</code>设置优先级。</p>
<p>优先级的等级在<code>MIN_PRIORITY</code>（默认值为1）和<code>MAX_PRIORITY</code>（默认值为10）之间；默认为<br><code>NORM_PRIORITY</code>(默认值为5).</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程的唯一用途是为其他线程通过服务。注意：守护线程应该永远不去<br>访问固有资源，如文件，数据库，因为它会在任何时刻甚至在一个操作中间<br>发生中断。</p>
<p>设置守护线程的方法<code>setDaemon(boolean isDaemon)</code></p>
<h2 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h2><p>当线程发生非受查异常时，我们可以设置异常处理器来处理这个异常，比如打印log或者报告给日志文件。</p>
<p>设置未捕获异常处理器的方法有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span><span class="comment">//UncaughtExceptionHandler处理异常的接口</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span></span></span><br></pre></td></tr></table></figure>
<p>注意：<code>setUncaughtExceptionHandler</code>的优先级高用<code>setDefaultUncaughtExceptionHandler</code></p>
<p>未捕获异常处理器的工作流程：</p>
<p>当线程发生异常时，会判断该线程是否通过<code>setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code>设置默认处理器；<br>如果设置了，就直接调用，否则调用<code>ThreadGroup</code>(ThreadGroup实现了UncaughtExceptionHandler接口)<br>的<code>void uncaughtException(Thread t, Throwable e);</code>方法。<code>ThreadGroup</code>中的<code>uncaughtException</code>的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;<span class="comment">//判断该线程是否有父线程组</span></span><br><span class="line">            parent.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在这里会判断atic void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)</span></span><br><span class="line">            <span class="comment">//方法是否设置了默认的处理器</span></span><br><span class="line">            Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">                Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">            <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ueh.uncaughtException(t, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;<span class="comment">//如果没有设置默认处理器，则输出到控制台上</span></span><br><span class="line">                System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                                 + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="竞争条件详解"><a href="#竞争条件详解" class="headerlink" title="竞争条件详解"></a>竞争条件详解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AMOUNT = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] account;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        account = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Arrays.fill(account,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (money&gt;account[from])<span class="comment">//转账数量大于账户余额</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(Thread.currentThread());</span><br><span class="line">        account[from]-=money;</span><br><span class="line">        System.out.print(from+<span class="string">"中的余额为 "</span>+account[from]);</span><br><span class="line">        account[to]+=money;</span><br><span class="line">        System.out.print(<span class="string">" "</span>+to+<span class="string">"中余额为 "</span> + account[to]);</span><br><span class="line">        System.out.println(<span class="string">"  "</span>+Thread.currentThread()+<span class="string">" 总余额为 "</span>+total());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value:account) &#123;</span><br><span class="line">            total+=value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> isContinue = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Bank bank = <span class="keyword">new</span> Bank(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = i;</span><br><span class="line">            Runnable runnable = ()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span> (isContinue)&#123;</span><br><span class="line">                    <span class="keyword">int</span> toAccount = (<span class="keyword">int</span>) (Math.random()*<span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">int</span> money = (<span class="keyword">int</span>) (Math.random()*Bank.MAX_AMOUNT);</span><br><span class="line">                    bank.transfer(from,toAccount,money);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">          Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">          isContinue = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]<span class="number">6</span>中的余额为 <span class="number">28</span> <span class="number">5</span>中余额为 <span class="number">40</span>  Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main] 总余额为 <span class="number">934</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]<span class="number">6</span>中的余额为 <span class="number">23</span> <span class="number">5</span>中余额为 <span class="number">45</span>  Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main] 总余额为 <span class="number">934</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]<span class="number">6</span>中的余额为 <span class="number">18</span> <span class="number">6</span>中余额为 <span class="number">23</span>  Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main] 总余额为 <span class="number">934</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]<span class="number">6</span>中的余额为 <span class="number">16</span> <span class="number">2</span>中余额为 <span class="number">127</span>  Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main] 总余额为 <span class="number">934</span></span><br><span class="line">Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main]<span class="number">6</span>中的余额为 <span class="number">0</span> <span class="number">7</span>中余额为 <span class="number">491</span>  Thread[Thread-<span class="number">6</span>,<span class="number">5</span>,main] 总余额为 <span class="number">934</span></span><br><span class="line">  Thread[Thread-<span class="number">7</span>,<span class="number">5</span>,main] 总余额为 <span class="number">995</span></span><br><span class="line">Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main]<span class="number">4</span>中的余额为 <span class="number">0</span> <span class="number">1</span>中余额为 <span class="number">163</span>  Thread[Thread-<span class="number">4</span>,<span class="number">5</span>,main] 总余额为 <span class="number">934</span></span><br><span class="line">Thread[Thread-<span class="number">9</span>,<span class="number">5</span>,main]<span class="number">9</span>中的余额为 <span class="number">42</span> <span class="number">6</span>中余额为 <span class="number">39</span>Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]<span class="number">1</span>中的余额为 <span class="number">159</span> <span class="number">1</span>中余额为 <span class="number">163</span>  Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main] 总余额为 <span class="number">934</span></span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]<span class="number">1</span>中的余额为 <span class="number">19</span> <span class="number">1</span>中余额为 <span class="number">1632</span>中的余额为 <span class="number">120</span> <span class="number">9</span>中余额为 <span class="number">101</span>Thread[Thread-<span class="number">5</span>,<span class="number">5</span>,main]<span class="number">5</span>中的余额为 <span class="number">42</span> <span class="number">6</span>中余额为 <span class="number">42</span>  Thread[Thread-<span class="number">5</span>,<span class="number">5</span>,main] 总余额为 <span class="number">993</span></span><br><span class="line">  Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main] 总余额为 <span class="number">977</span></span><br><span class="line"><span class="number">8</span>中的余额为 <span class="number">2</span> <span class="number">4</span>中余额为 <span class="number">03</span>中的余额为 <span class="number">1</span> <span class="number">8</span>中余额为 <span class="number">25</span>Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]<span class="number">0</span>中的余额为 <span class="number">6</span>  Thread[Thread-<span class="number">8</span>,<span class="number">5</span>,main] 总余额为 <span class="number">993</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从运行结果可知，程序出现了问题。下面详细介绍下问题的原因：</p>
<p>问题在于这不是原子操作，指令可能被处理如下：</p>
<ol>
<li>将<code>accounts[to]</code>加载到寄存器</li>
<li>增加<code>amount</code></li>
<li>将结果写回<code>accounts[to]</code></li>
</ol>
<p>现在假设第一个线程执行了步骤1和2，然后，它被剥夺了优先权。假设第2个线程被唤醒并修改了<code>accounts</code>数组中同一项，然后第一个线程被唤醒并完成第3步。<br>这样，这一动作擦去了第二个线程所做的更新，于是总金额不再正确。</p>
<h2 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h2><p>Java中提供了两种机制防止代码块受并发访问的干扰</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code>实现同步的基础：</p>
<ul>
<li>Java中每个对象都可以作为锁。当线程试图访问同步代码时，必须先获得对象锁，退出或抛出异常时必须释放锁。</li>
<li><code>Synchronzied</code>实现同步的表现形式分为：代码块同步 和 方法同步。</li>
</ul>
<p><code>synchronized</code>的使用场景</p>
<p>方法同步:</p>
<p><code>public synchronized void method1</code></p>
<p>(1)锁住的是该对象,类的其中一个实例，当该对象(仅仅是这一个对象)在不同线程中执行这个同步方法时，线程之间会形成互斥。达到同步效果，但如果不同线程同时对该类的不同对象执行这个同步方法时，则线程之间不会形成互斥，因为他们拥有的是不同的锁。</p>
<p>代码块同步:</p>
<p><code>synchronized(this){ //TODO }</code></p>
<p>描述同(1)</p>
<p>方法同步:</p>
<p><code>public synchronized static void method3</code></p>
<p>(2)锁住的是该类，当所有该类的对象(多个对象)在不同线程中调用这个static同步方法时，线程之间会形成互斥，达到同步效果。</p>
<p>代码块同步</p>
<p><code>synchronized(Test.class){ //TODO}</code></p>
<p>描述同(2)</p>
<p>代码块同步:</p>
<p><code>synchronized(o) {}</code></p>
<p>这里面的o可以是一个任何Object对象或数组，并不一定是它本身对象或者类，谁拥有o这个锁，谁就能够操作该块程序代码</p>
<h3 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h3><p><code>ReentranLock</code>的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();<span class="comment">//获取锁对象</span></span><br><span class="line"><span class="keyword">try</span>&#123;<span class="comment">//如果使用锁，就不能使用带资源的`try`语句。</span></span><br><span class="line"><span class="comment">//具体方法体</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();<span class="comment">//确保释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为<code>Bank</code>类加上锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (money&gt;account[from])<span class="comment">//转账数量大于账户余额</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            System.out.print(Thread.currentThread());</span><br><span class="line">            account[from]-=money;</span><br><span class="line">            System.out.print(from+<span class="string">"中的余额为 "</span>+account[from]);</span><br><span class="line">            account[to]+=money;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+to+<span class="string">"中余额为 "</span> + account[to]);</span><br><span class="line">            System.out.println(<span class="string">"  "</span>+Thread.currentThread()+<span class="string">" 总余额为 "</span>+total());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>每一个<code>Bank</code>对象都有自己的<code>ReentrantLock</code>对象。如果两个线程试图访问同一个<code>Bank</code>对象，那么锁以串行方式提供服务。但是，如果两个线程<br>访问不同的<code>Bank</code>对象，每一个线程得到不同的锁对象，两个线程都不会发生堵塞，因为线程在操作不同的<code>Bank</code>实例时，线程之间不会相互影响。</p>
<p><code>ReentranLock</code>的常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>: 执行此方法时，如果锁处于空闲状态，当前线程将获取到锁。相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>： 如果锁可用，则获取锁，并立即返回<span class="keyword">true</span>，否则返回<span class="keyword">false</span>. 该方法和<span class="title">lock</span><span class="params">()</span>的区别在于，<span class="title">tryLock</span><span class="params">()</span>只是"试图"获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码。而<span class="title">lock</span><span class="params">()</span>方法则是一定要获取到锁，如果锁不可用，就一直等待，在未获得锁之前,当前线程并不继续向下执行. 通常采用如下的代码形式调用<span class="title">tryLock</span><span class="params">()</span>方法：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>： 执行此方法时，当前线程将释放持有的锁. 锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span>： 条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的<span class="title">await</span><span class="params">()</span>方法，而调用后，当前线程将释放锁</span></span><br></pre></td></tr></table></figure>
<h2 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h2><p>在上面对转款超过自己余额的操作是直接取消这次操作，这个符合一般的常识。但是有时候我们我们会等待别人转账过来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (money&gt;account[from])</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (money&gt;account[from])</span><br><span class="line">    wait();</span><br></pre></td></tr></table></figure>
<p>但是由于这个线程获得了锁，具有排他性，因此没有别的线程可以转账，为了解决这个问题，我们可以使用条件对象(或者叫做条件变量)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (money&gt;account[from])<span class="comment">//转账数量大于账户余额</span></span><br><span class="line">                condition.await();<span class="comment">//让线程等待，进入阻塞状态，并放弃锁</span></span><br><span class="line">            System.out.print(Thread.currentThread());</span><br><span class="line">            account[from]-=money;</span><br><span class="line">            System.out.print(from+<span class="string">"中的余额为 "</span>+account[from]);</span><br><span class="line">            account[to]+=money;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+to+<span class="string">"中余额为 "</span> + account[to]);</span><br><span class="line">            System.out.println(<span class="string">"  "</span>+Thread.currentThread()+<span class="string">" 总余额为 "</span>+total());</span><br><span class="line">            condition.signalAll();<span class="comment">//解除所有该条件等待线程的阻塞状态</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>注意：<code>signalAll()</code>方法不会立即激活一个等待线程，它仅仅解除阻塞状态，以便这些线程可以在当前线程退出同步方法后，通过<br>竞争实现对对象的访问。另一个方法<code>signal()</code>只会随机解除一个线程的阻塞状态，如果随机选择的线程仍然不能运行，就会再次阻塞，<br>如果没有其他线程再次调用<code>signal()</code>，那么系统就死锁了。</p>
<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>转载<a href="https://lrh1993.gitbooks.io/android_interview_guide/content/java/concurrence/synchronized-reentrantlock.html" target="_blank" rel="noopener">线程同步问题的产生及解决方案</a></p>
<p>当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。<br>具体概念就是：自己可以再次获取自己的内部锁。<br>Java里面内置锁(synchronized)和Lock(ReentrantLock)都是可重入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法1获得ReentrantTest的锁运行了"</span>);</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法1里面调用的方法2重入锁,也正常运行了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SynchronizedTest().method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面便是synchronized的重入锁特性，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时，由于本身已经具有该锁，所以可以再次获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法1获得ReentrantLock锁运行了"</span>);</span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"方法1里面调用的方法2重入ReentrantLock锁,也正常运行了"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReentrantLockTest().method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面便是ReentrantLock的重入锁特性，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时， 由于本身已经具有该锁，所以可以再次获取。</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>转载<a href="https://lrh1993.gitbooks.io/android_interview_guide/content/java/concurrence/synchronized-reentrantlock.html" target="_blank" rel="noopener">线程同步问题的产生及解决方案</a></p>
<p>CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程先到先得的（synchronized控制的锁就是这种非公平锁）。</p>
<p>但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。</p>
<p>那么如何解决饥饿问题呢，这就需要公平锁了。公平锁可以保证线程按照时间的先后顺序执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。</p>
<p>ReentrantLock便是一种公平锁，通过在构造方法中传入true就是公平锁，传入false，就是非公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">以下是使用公平锁实现的效果：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFairTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"获得锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockFairTest lft=<span class="keyword">new</span> LockFairTest();</span><br><span class="line">        Thread th1=<span class="keyword">new</span> Thread(lft);</span><br><span class="line">        Thread th2=<span class="keyword">new</span> Thread(lft);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Thread-<span class="number">1</span>获得锁 </span><br><span class="line">Thread-<span class="number">0</span>获得锁 </span><br><span class="line">Thread-<span class="number">1</span>获得锁 </span><br><span class="line">Thread-<span class="number">0</span>获得锁 </span><br><span class="line">Thread-<span class="number">1</span>获得锁 </span><br><span class="line">Thread-<span class="number">0</span>获得锁 </span><br><span class="line">Thread-<span class="number">1</span>获得锁 </span><br><span class="line">Thread-<span class="number">0</span>获得锁 </span><br><span class="line">Thread-<span class="number">1</span>获得锁 </span><br><span class="line">Thread-<span class="number">0</span>获得锁 </span><br><span class="line">Thread-<span class="number">1</span>获得锁 </span><br><span class="line">Thread-<span class="number">0</span>获得锁 </span><br><span class="line">Thread-<span class="number">1</span>获得锁 </span><br><span class="line">Thread-<span class="number">0</span>获得锁 </span><br><span class="line">Thread-<span class="number">1</span>获得锁 </span><br><span class="line">Thread-<span class="number">0</span>获得锁</span><br></pre></td></tr></table></figure>
<p>这是截取的部分执行结果，分析结果可看出两个线程是交替执行的，几乎不会出现同一个线程连续执行多次。</p>
<h2 id="synchronized和ReentrantLock的比较"><a href="#synchronized和ReentrantLock的比较" class="headerlink" title="synchronized和ReentrantLock的比较"></a>synchronized和ReentrantLock的比较</h2><p>转载<a href="https://lrh1993.gitbooks.io/android_interview_guide/content/java/concurrence/synchronized-reentrantlock.html" target="_blank" rel="noopener">线程同步问题的产生及解决方案</a></p>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul>
<li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li>
<li>Lock可以提高多个线程进行读操作的效率。</li>
</ul>
<p>总结：ReentrantLock相比synchronized，增加了一些高级的功能。但也有一定缺陷。<br>在ReentrantLock类中定义了很多方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isFair()      <span class="comment">//判断锁是否是公平锁</span></span><br><span class="line"></span><br><span class="line">isLocked()    <span class="comment">//判断锁是否被任何线程获取了</span></span><br><span class="line"></span><br><span class="line">isHeldByCurrentThread()   <span class="comment">//判断锁是否被当前线程获取了</span></span><br><span class="line"></span><br><span class="line">hasQueuedThreads()   <span class="comment">//判断是否有线程在等待该锁</span></span><br></pre></td></tr></table></figure>
<p>两者在锁的相关概念上区别：</p>
<p>1)可中断锁<br><br>顾名思义，就是可以响应中断的锁。<br><br>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。<br>lockInterruptibly()的用法体现了Lock的可中断性。</p>
<p>2)公平锁<br><br>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁（并不是绝对的，大体上是这种顺序），这种就是公平锁。<br>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。ReentrantLock可以设置成公平锁。</p>
<p>3)读写锁<br><br>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。<br>正因为有了读写锁，才使得多个线程之间的读操作可以并发进行，不需要同步，而写操作需要同步进行，提高了效率。<br>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。<br>可以通过readLock()获取读锁，通过writeLock()获取写锁。</p>
<p>4)绑定多个条件<br><br>一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这么做，只需要多次调用new Condition()方法即可。</p>
<p>3.性能比较</p>
<p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而 当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized 。所以说，在具体使用时要根据适当情况选择。</p>
<p>在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的ReentrankLock对象，性能更高一些。</p>
<p>到了JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/05/windows的路径/" rel="next" title="windows的路径">
                <i class="fa fa-chevron-left"></i> windows的路径
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/user.jpg" alt="lichukuan">
            
              <p class="site-author-name" itemprop="name">lichukuan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">博客</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程创建的方法"><span class="nav-number">1.</span> <span class="nav-text">线程创建的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable"><span class="nav-number">1.1.</span> <span class="nav-text">Runnable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread"><span class="nav-number">1.2.</span> <span class="nav-text">Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable和Future"><span class="nav-number">1.3.</span> <span class="nav-text">Callable和Future</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的状态"><span class="nav-number">2.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程中断"><span class="nav-number">3.</span> <span class="nav-text">线程中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join方法"><span class="nav-number">4.</span> <span class="nav-text">join方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程优先级"><span class="nav-number">5.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#守护线程"><span class="nav-number">6.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未捕获异常处理器"><span class="nav-number">7.</span> <span class="nav-text">未捕获异常处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#竞争条件详解"><span class="nav-number">8.</span> <span class="nav-text">竞争条件详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁对象"><span class="nav-number">9.</span> <span class="nav-text">锁对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized"><span class="nav-number">9.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentranLock"><span class="nav-number">9.2.</span> <span class="nav-text">ReentranLock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件对象"><span class="nav-number">10.</span> <span class="nav-text">条件对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重入锁"><span class="nav-number">11.</span> <span class="nav-text">重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#公平锁"><span class="nav-number">12.</span> <span class="nav-text">公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和ReentrantLock的比较"><span class="nav-number">13.</span> <span class="nav-text">synchronized和ReentrantLock的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#区别："><span class="nav-number">13.1.</span> <span class="nav-text">区别：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lichukuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
